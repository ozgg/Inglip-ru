<%
  handler = LexemeHandler::Noun.new(entity)
  entity.flags = LexemeHandler::Noun.default_lexeme_flags if entity.id.nil?
  model_name = entity.class.to_s.underscore
%>
<%=
  form_with(
      model: entity,
      html:  {
          id:           "#{model_name}-form",
          autocomplete: 'off'
      }
  ) do |f|
%>
  <%= render partial: 'shared/list_of_errors', locals: { entity: entity } %>

  <fieldset>
    <legend><%= t('lexemes.form.lexeme') %></legend>
    <div class="field">
      <div>
        <%= f.label :body %>
      </div>
      <div>
        <%=
          f.text_field(
              :body,
              id:        "#{model_name}_body",
              size:      nil,
              maxlength: Lexeme::BODY_LIMIT,
              required:  true
          )
        %>
        <div class="guideline"><%= t('lexemes.form.guidelines.body') %></div>
      </div>
    </div>
    <div class="field">
      <div>
        <%= f.label :context %>
      </div>
      <div>
        <%=
          f.text_field(
              :context,
              id:        "#{model_name}_context",
              size:      nil,
              maxlength: Lexeme::CONTEXT_LIMIT
          )
        %>
        <div class="guideline"><%= t('lexemes.form.guidelines.context') %></div>
      </div>
    </div>
    <div class="flag">
      <%= f.check_box :declinable, id: "#{model_name}_declinable" %>
      <%= f.label :declinable %>
    </div>
    <ul class="flags">
      <% LexemeHandler::Noun.lexeme_flags.each do |flag, value| %>
        <li>
          <% entity_id = "lexeme_flag_#{flag}" %>
          <%= check_box_tag("lexeme_flags[#{flag}]", value, handler.flag?(flag), id: entity_id) %>
          <%= label_tag(entity_id, t("lexeme_flags.noun.#{flag}")) %>
        </li>
      <% end %>
    </ul>
  </fieldset>

  <fieldset>
    <legend><%= t('lexemes.form.wordforms') %></legend>

    <div class="auto-inflect">
      <button type="button" class="button-action" id="noun-magic">✨</button>
    </div>

    <%
      groups = %i[number_singular number_plural]
      cases = %i[case_nominative case_genitive case_dative case_accusative case_instrumental case_prepositional case_partitive case_locative]
    %>
    <div class="wordforms" id="wordforms">
      <% groups.each do |group_flag_name| %>
        <div class="group <%= group_flag_name %>">
          <div class="header"><%= t("wordform_flags.#{group_flag_name}") %></div>
          <ul>
            <% cases.each do |case_flag_name| %>
              <li class="<%= case_flag_name %>">
                <%
                  element_id = "wordform-#{group_flag_name}-#{case_flag_name}"
                  flag_value = LexemeHandler.wordform_flag(group_flag_name, case_flag_name)
                %>
                <%= label_tag(element_id, t("wordform_flags.#{case_flag_name}")) %>
                <%=
                  text_field_tag(
                      "wordforms[#{flag_value}]",
                      handler.wordform(flag_value),
                      id: element_id,
                      size: nil,
                      maxlength: Word::BODY_LIMIT
                  )
                %>
              </li>
            <% end %>
          </ul>
        </div>
      <% end %>
    </div>
  </fieldset>

  <div class="buttons">
    <%= f.hidden_field :lexeme_type_id if entity.id.nil? %>
    <%= f.button t(:save), type: :submit, class: 'button-save' %>
  </div>
<% end %>

<script>
    'use strict';

    document.addEventListener('DOMContentLoaded', function () {
        const hide = (item) => {
            item.classList.add('hidden');
            item.querySelectorAll('input').forEach((f) => f.value = '');
        };
        const show = (item) => item.classList.remove('hidden');

        const checkState = (flag, list) => {
            const callback = flag.checked ? show : hide;

            list.forEach((item) => callback(item));
        };

        const mapping = [
            ['lexeme_flag_has_partitive', 'li.case_partitive'],
            ['lexeme_flag_has_locative', 'li.case_locative'],
            ['lexeme_flag_singular_form', 'div.number_singular'],
            ['lexeme_flag_plural_form', 'div.number_plural'],
        ];

        mapping.forEach(function (pair) {
            const flag = document.getElementById(pair[0]);
            const list = document.querySelectorAll(pair[1]);

            checkState(flag, list);

            flag.addEventListener('change', () => checkState(flag, list));
        });

        const inflector = document.getElementById('noun-magic');
        inflector.addEventListener('click', function () {
            const infinitive = document.getElementById('lexeme_body');
            if (infinitive.value === '') {
                infinitive.focus();
                return;
            }

            const declinable = document.getElementById('lexeme_declinable').checked;
            if (!declinable) {
                document.querySelectorAll('#wordforms input').forEach(function (field) {
                    if (field.value === '') {
                        field.value = infinitive.value;
                    }
                });
                return;
            }

            const animated = document.getElementById('lexeme_flag_animated').checked;

            let gender = '';
            if (document.getElementById('lexeme_flag_gender_masculine').checked) {
                gender = 'm';
            } else if (document.getElementById('lexeme_flag_gender_feminine').checked) {
                gender = 'f'
            } else if (document.getElementById('lexeme_flag_gender_neuter').checked) {
                gender = 'n';
            }

            const ending = infinitive.value.slice(-1);
            const penultimate = infinitive.value.slice(-2).substring(0, 1);
            const sibilant = ['ж', 'ш', 'щ', 'ч', 'ц'].includes(penultimate);
            let soften = ['г', 'к', 'ш', 'ж'].includes(penultimate);

            let root, endings, plurals;

            if (gender === 'm') {
                switch (ending) {
                    case 'а':
                        soften |= sibilant;
                        root = infinitive.value.slice(0, -1);
                        endings = [soften ? 'и' : 'ы', 'е', animated ? 'у' : ending, 'ой', 'е'];
                        plurals = [soften ? 'и' : 'ы', '', 'ам', animated ? '' : (soften ? 'и' : 'ы'), 'ами', 'ах'];
                        break;
                    case 'я':
                        root = infinitive.value.slice(0, -1);
                        endings = ['и', 'е', animated ? 'ю' : ending, 'ей', 'е'];
                        plurals = ['и', 'ь', 'ям', animated ? 'ей' : 'и', 'ями', 'ях'];
                        break;
                    case 'ь':
                        root = infinitive.value.slice(0, -1);
                        endings = ['я', 'ю', animated ? 'я' : ending, 'ем', 'е'];
                        plurals = ['и', 'ей', 'ям', animated ? 'ей' : 'и', 'ями', 'ях'];
                        break;
                    case 'о':
                        root = infinitive.value.slice(0, -1);
                        endings = ['и', 'е', animated ? 'ю' : ending, 'ой', 'е'];
                        plurals = ['и', 'ек', 'ам', animated ? 'ек' : 'и', 'ами', 'ах'];
                        break;
                    case 'е':
                        root = infinitive.value.slice(0, -1);
                        soften = !['ч', 'щ'].includes(root.slice(-1));
                        endings = [soften ? 'я' : 'а', soften ? 'ю' : 'у', animated ? 'а' : ending, 'ем', 'е'];
                        plurals = [sibilant ? 'и' : 'ы', '', sibilant ? 'ям' : 'ам', animated ? 'ей' : (sibilant ? 'и' : 'ы'), 'ами', 'ах'];
                        break;
                    case 'щ':
                        root = infinitive.value;
                        endings = ['а', 'у', animated ? 'а' : '', 'ом', 'е'];
                        plurals = ['и', 'ей', 'ам', animated ? 'ей' : 'и', 'ами', 'ах'];
                        break;
                    case 'й':
                        root = infinitive.value.slice(0, -1);
                        endings = ['я', 'ю', animated ? 'я' : ending, 'ем', 'е'];
                        plurals = ['и', 'ев', 'ям', animated ? 'ев' : 'и', 'ями', 'ях'];
                        break;
                    default:
                        if ((ending === 'к') && ['о', 'ё'].includes(penultimate)) {
                            root = infinitive.value.slice(0, -2);
                            if (penultimate === 'ё') {
                                root += 'ь';
                            }
                            endings = ['ка', 'ку', animated ? 'ка' : (penultimate + 'к'), 'ком', 'ке'];
                            plurals = ['ки', 'ков', 'кам', animated ? 'ков' : 'ки', 'ками', 'ках'];
                        } else if (ending === 'н' && penultimate === 'и' && animated) {
                            root = infinitive.value.slice(0, -2);
                            endings = ['на', 'ну', 'на', 'ном', 'не'];
                            plurals = ['е', '', 'ам', '', 'ами', 'ах'];
                        } else {
                            soften = ['г', 'к'].includes(ending);
                            root = infinitive.value;
                            endings = ['а', 'у', animated ? 'а' : '', 'ом', 'е'];
                            plurals = [soften ? 'и' : 'ы', 'ов', 'ам', animated ? 'ов' : (soften ? 'и' : 'ы'), 'ами', 'ах'];
                        }
                        break;
                }
            } else if (gender === 'f') {
                switch (ending) {
                    case 'а':
                        root = infinitive.value.slice(0, -1);
                        endings = [soften ? 'и' : 'ы', 'е', 'у', sibilant ? 'ей' : 'ой', 'е'];
                        plurals = [soften ? 'и' : 'ы', '', 'ам', animated ? '' : (soften ? 'и' : 'ы'), 'ами', 'ах'];
                        break;
                    case 'я':
                        root = infinitive.value.slice(0, -1);
                        endings = ['и', 'е', 'ю', 'ей', 'е'];
                        plurals = ['и', 'ь', 'ям', animated ? 'ь' : 'и', 'ями', 'ях'];
                        break;
                    case 'ь':
                        soften = !in_array(penultimate, ['ж', 'ш', 'щ', 'ч']);
                        root = infinitive.value.slice(0, -1);
                        endings = ['и', 'и', ending, ending + 'ю', 'и'];
                        plurals = ['и', 'ей', soften ? 'ям' : 'ам', animated ? 'ей' : 'и', soften ? 'ями' : 'ами', soften ? 'ях' : 'ах'];
                        break;
                    default:
                        root = infinitive.value;
                        endings = ['', '', '', '', ''];
                        plurals = ['', '', '', animated ? '' : '', '', ''];
                        break;
                }
            } else if (gender === 'n') {
                switch (ending) {
                    case 'о':
                        root = infinitive.value.slice(0, -1);
                        endings = ['а', 'у', ending, 'ом', 'е'];
                        plurals = ['а', '', 'ам', animated ? '' : 'а', 'ами', 'ах'];
                        break;
                    case 'е':
                        root = infinitive.value.slice(0, -1);
                        soften = !['ч', 'щ', 'ж', 'ш'].includes(penultimate);
                        endings = [soften ? 'я' : 'а', soften ? 'ю' : 'у', ending, 'ем', 'е'];
                        if (penultimate === 'и') {
                            endings[5] = 'и';
                            plurals = ['я', 'й', 'ям', animated ? 'й' : 'я', 'ями', 'ях'];
                        } else {
                            plurals = [soften ? 'я' : 'а', 'ей', soften ? 'ям' : 'ам', animated ? 'ей' : (soften ? 'я' : 'а'), soften ? 'ями' : 'ами', soften ? 'ях' : 'ах'];
                        }
                        break;
                    case 'я':
                        root = infinitive.value.slice(0, -1);
                        endings = ['ени', 'еню', 'я', 'енем', 'ени'];
                        plurals = ['ена', 'ян', 'енам', animated ? 'ян' : 'ена', 'енами', 'енах'];
                        break;
                    default:
                        root = infinitive.value;
                        endings = ['', '', '', '', ''];
                        plurals = ['', '', '', animated ? '' : '', '', ''];
                        break;
                }
            } else {
                root = infinitive.value;
                endings = ['', '', '', '', ''];
                plurals = ['', '', '', '', '', ''];
            }

            document.getElementById('wordform-number_singular-case_nominative').value = infinitive.value;

            const mapping = {
                "singular": {
                    "genitive": root + endings[0],
                    "partitive": root + endings[0],
                    "dative": root + endings[1],
                    "accusative": root + endings[2],
                    "instrumental": root + endings[3],
                    "prepositional": root + endings[4],
                    "locative": root + endings[4]
                },
                "plural": {
                    "nominative": root + plurals[0],
                    "genitive": root + plurals[1],
                    "partitive": root + plurals[1],
                    "dative": root + plurals[2],
                    "accusative": root + plurals[3],
                    "instrumental": root + plurals[4],
                    "prepositional": root + plurals[5],
                    "locative": root + plurals[5],
                }
            };

            for (let number in mapping) {
                if (mapping.hasOwnProperty(number)) {
                    for (let grammatical_case in mapping[number]) {
                        if (mapping[number].hasOwnProperty(grammatical_case)) {
                            const id = `wordform-number_${number}-case_${grammatical_case}`;
                            const element = document.getElementById(id);
                            const parent = element.closest('li');

                            if (parent.classList.contains('hidden')) {
                                element.value = '';
                            } else {
                                element.value = mapping[number][grammatical_case];
                            }
                        }
                    }
                }
            }
        });
    });
</script>
